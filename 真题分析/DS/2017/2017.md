# 2017
## 选择题
1. B  
设t轮后退出后循环， 那么 $1+2+3+\cdots + t = \frac{t(t+1)}2 > n$ ,可见 $t^2$ 和问题规模n之间的关系  
1. C  
A.递归可以用迭代改写， 这时不需要栈  
C.不一定， 相同的入栈次序有 $\frac{1}{n+1}C_{2n}^{n}$ 种出栈  
D. 只能在一段  
1. A  
课本原话， 三元组是因为可以存储{i, j, val}, 最后再存储一下{n, m, 非0元素个数}  
采用十字链表是因为可以用一条链记录i行,一条链记录i列，故可以用十字链表  
1. B  
要让左根右， 和根左右相同， 显而易见没有左即可  
1. B  
会写后序就行，模拟一遍， 最终的树：inorder[c, e, a, f, d, b, g], preorder[f, c, a, e, g, d, b]  
1. D  
开头的0100（a）011(f) 0010(e)选D  
1. B  
总度数是32， 那么度数为0， 1， 2所占度数为$32-12-12=8$， 要让节点最少， 那就是4个度为2的顶点，节点总数$4+3+4=11$  
1. A  
这是这里 $\lceil \frac{i+j}2 \rceil$ 故分支先往左伸展， b,c一眼错， 对于c， 如果第三层有三个节点的话， 一定是左边两个， 右边一个， 像a那样  
1. B  
b+树主要是对于大数据集建立索引加速查找， 对于a肯定用不到， c的数据集不够大， 没必要建立b+树， 做个红黑树就能满足要求， d由于空闲块没有键， 其除了大小几乎无差别， 所以不适合b+树  
1.  B  
这个第一问出的有的**， 到底多短算短？10行？100行？1000行？10000行？， 就算是相比于其他算法， 不同程序员的不同编写习惯， 代码长短也会不一  
分析第二问， 如果要求更少的占用空间O(n)， 那么完全可以选择堆排O(1)或者快排 $O(log_2 n)$  
运行效率的确高 $O(log_2 n)$  
1.  D  
i, ii, iii的算法每次移动都是从相邻元素之间移动，性能不会有损耗，而希尔涉及d的序列， 堆排序需要找孩子和父亲， 都是需要跨好几个节点访问， 所以如果不能随机访问， 就会降低性能
## 应用题
1):  
AD, DE, EC, BC  
2):  
是唯一的  
3):  
任意环中不存在相同权值的边时， MST唯一  
注： 据0x3F(著名算法讲师)介绍， 上述为必要条件，充要条件是不存在伪关键边  
具体见：https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/description/