# 2012
## 选择题
1. B  
送分题  
1. A  
有符号出栈时判断一下即可  
遍历到-时， 栈内{+}  
遍历到第一个)时， 栈内{- * （ （ +}  
遍历到-时， 栈内 {- * （ /}  
遍历到第二个）时, 栈内 { - * （ /}  
遍历到+时, 栈内{- *}
结束时，栈内 {+}  
可见最大是5  
1. A  
先看简单情况，若e是a的右孩子， 那么先序遍历中a后紧跟e， 左边不可能有节点  
若e是左孩子，由于b时后序第一个节点， 所以bc链只可能在e或d下，接下来后序是c， 故排除dc链在a节点下可能性（若dc链在a下， 那么后序中b后应是e）
1. B  
直接套公式  
h1 = 1  
h2 = 2  
h3 = h2 + h1 + 1  
h4 = h3 + h2 + 1  
h5 = h4 + h3 + 1  
h6 = h5 + h4 + 1  
解得h6 = 20  
1. C  
BFS遍历每个点的每条边， 所以有向图是$O(n + e)$，无向图是$O(n + 2e)$  
1. C  
肯定可以按照123456...n的顺序消去所有元素， 但可能存在其他可能序列， 故存在， 可能不唯一， 随意举例[[0, 0, 1], [0, 0, 1], [0, 0, 0]]  
1. C  
模拟一遍dijkstra即可  
dis:  
[0, 2, 5, inf, inf, inf]  
[0, 2, 3, 5, inf, inf]  
[0, 2, 3, 8, 7, 4]  
[0, 2, 3, 8, 7, 4]写到这里其实就已经结束了  
1. A  
i: 最小生成树的定义  
ii: 不可能， 随意举例：有三个顶点三条权值相同边的环, 最小生成树肯定会不包含其中一条边
iii: 这是可能不同的  
iv: 不一定相同  
1. D  
考察B树删除， 左兄弟够借， 直接把65拿来当右子树， 62放在父节点里即可  
1.  A  
知道每种排序说的啥就很好判断了  
1.  D  
折半插入可以比直接插入少或者多比较次数
## 应用题
1):  
按最短的先合并， 即10和35合并最差比较44次， 生成长度为45的升序表，然后长度40和45合并最差比较84次， 生成长度为85的升序表，然后长度50和60合并最差比较109次， 生成长度为110的升序表，然后长度110和85合并最差比较194次， 生成长度为195的升序表，然后长度195和200合并最差比较394次， 生成长度为395的升序表，总比较次数为44+109+194+394=741次  
2):  
先合并最短的两个，然后依次合并， 依照哈夫曼树的构造，这样最多比较分支节点的值之和再减去分支节点数