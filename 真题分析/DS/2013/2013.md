# 2013
## 选择题
1. D  
最坏是两个链表需要注意比较，即O(m+n) => O(max(m, n))  
1. C  
若p1或是1或是2时，p3可取3到n所有数  
若p1是2时，p3可取1  
若p1是1时，p3可取2  
综上所述，p3能取3以外任何数  
1. D  
模拟一遍插入过程即可, 最终的树  
preorder = [4, 2, 1, 3, 6, 5, 7]  
inorder = [1, 2, 3, 4, 5, 6, 7]  
1. B  
只要能意识到外部排序中的最佳归并树， 那么这道题就很简单了  
补 $3 - (n-1)\mod (k-1) - 1 = 1$ 个虚段， 然后构建哈夫曼树即可  
1. A  
后序遍历中X没有孩子的话，下一个遍历的就是父节点  
1. C  
若A是叶节点， 那么删除后不调整树的其他节点， 下次插入还是在那个位置
若A时分支节点， 那么删除后必将导致一个叶节点变成分支节点， 而在下次插入时，不调整树的结构， 所以肯定不同  
1. C  
由于是非对称矩阵， 所以是有向图， 那么i节点的度就是 $\sum\limits_{j=0}^{n-1}a[i][j] + \sum\limits_{k=0}^{n-1}a[k][i]$  
1. D  
模拟一遍BFS入队即可  
D: 在遍历e之前是不会遍历c的，错误  
1. C  

    |1 |2 |3 |4 |5 |6 |  
    |- |- |- |- |- |- |  
    |0|12|8|21|18|27|  
    |0|12|8|21|18|27|

    |a|b|c|d|e|f|g|h|  
    |-|-|-|-|-|-|-|-|
    |0|0|12|8|12|8|21|18|
    |9|0|12|8|12|8|21|18|
    
    可见除a外都是关键边， 要缩短时期，就要缩短所有关键路径上的某条关键边  
    对于A，没有缩短bfg， 对于B，没有缩短bfg， 对于D，没有缩短dcg  
2.  A  
不难想象第一层一个节点， 第二层两个节点内各两个1节点  
1.  C  
数据的十位数为升序， 十位数相同时个位数升序  
A. 911和114位置错误  
B. 114， 911， 122， 120位置错误  
C. 正确  
D. 120一眼位置错误
## 应用题
1):  
若要顺序存储平均查找长度最短， 那么把概率大的往前放，即排列为[do, while, for, rerpeat], 此时平均查找长度为1 * 0.35 + 2 * 0.35 + 3 * 0.15 + 4 * 0.15 = 2.1， 由于折半查找是2.2，故采用顺序查找  
2):  
若是链式存储， 则只能顺序查找， 按照第一问的方式排列， 此时平均查找长度是2.1